Let's Start with the Factory Method Pattern
âœ… What is Factory Method Pattern?
A Factory Method is a design pattern that:

Encapsulates object creation logic, allowing subclasses or components to decide which class to instantiate.

â“ Why Do We Need It?
Imagine you donâ€™t use Factory Pattern and do this:

func main() {
	db := MySQL{}
	fs := FileSystemStorage{}
logger := ConsoleLogger{}
}
Now your main() knows:

About all types (MySQL, FileSystemStorage, ConsoleLogger)

How to initialize them

When to use which

â¡ï¸ This creates tight coupling, violates OCP, and makes testing or switching implementations a pain.

ğŸ”¥ Benefits of Factory Method:
Benefit	Why Itâ€™s Valuable
OCP-friendly	Add new types without touching client code
DIP-friendly	Create concrete types behind interfaces
Cleaner main()	No new scattered everywhere
Testing becomes easy	Swap mocks via factory

ğŸ—ï¸ Analogy
You're building a house. Do you:

A: Create your own doors, windows, and bricks every time manually?

B: Ask the construction company to give you what you need?

Factory Method is like the construction company â€” it gives you the right object, ready to use, and abstracts the creation logic.

âœ… Real Example in Go: Notification Service
Weâ€™ll build a factory that returns a notifier (SMS, Email, Slack) depending on config.

ğŸ¯ Goal:

notifier := notifierFactory("slack")
notifier.Send("Backup completed")
ğŸ’» Code

package main

import "fmt"

// --- Notifier Interface ---
type Notifier interface {
	Send(message string)
}

// --- Concrete Notifiers ---
type EmailNotifier struct{}
func (e EmailNotifier) Send(msg string) {
	fmt.Println("Email:", msg)
}

type SMSNotifier struct{}
func (s SMSNotifier) Send(msg string) {
	fmt.Println("SMS:", msg)
}

type SlackNotifier struct{}
func (s SlackNotifier) Send(msg string) {
	fmt.Println("Slack:", msg)
}

// --- Factory Method ---
func GetNotifier(channel string) Notifier {
	switch channel {
	case "email":
		return EmailNotifier{}
	case "sms":
		return SMSNotifier{}
	case "slack":
		return SlackNotifier{}
	default:
		panic("Unsupported notification channel: " + channel)
	}
}

// --- Main ---
func main() {
	notifier := GetNotifier("slack")
	notifier.Send("Backup completed")
}
ğŸ§  What You Achieved
âœ… main() only depends on the Notifier interface
âœ… You can add new notifiers without touching main()
âœ… Swappable in tests
âœ… Centralized creation logic

ğŸ”¥ If You Didnâ€™t Use Factory Pattern?
Youâ€™d need:

if config == "email" {
    notifier = EmailNotifier{}
} else if config == "sms" {
    notifier = SMSNotifier{}
}
And this logic would be scattered across the codebase.

Adding a new channel requires modifying all those places.

Breaks Open/Closed Principle

Harder to test â€” can't easily inject mocks

