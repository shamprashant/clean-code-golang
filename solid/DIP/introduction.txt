üî∑ D ‚Äì Dependency Inversion Principle (DIP)
‚úÖ Definition:
High-level modules should not depend on low-level modules.
Both should depend on abstractions.
Abstractions should not depend on details.
Details should depend on abstractions.

üß† In Go Terms:
Let‚Äôs say you have a controller that uses a concrete service:

type FileLogger struct{}

func (f FileLogger) Log(msg string) {
	fmt.Println("Writing to file:", msg)
}

type Controller struct {
	logger FileLogger // ‚ùå high-level code depends on low-level detail
}

func (c Controller) Process() {
	c.logger.Log("Processing request")
}
This is tight coupling ‚Äî Controller depends on a specific logger.

‚úÖ DIP-compliant version:
type Logger interface {
	Log(string)
}

type FileLogger struct{}
func (f FileLogger) Log(msg string) {
	fmt.Println("Writing to file:", msg)
}

type Controller struct {
	logger Logger // ‚úÖ high-level depends on abstraction
}

func (c Controller) Process() {
	c.logger.Log("Processing request")
}
Now you can inject any logger: ConsoleLogger, RemoteLogger, etc.

üí° Key Insight:
High-level logic (like Controller) should not care how logging is done.

We invert the dependency by injecting abstractions, not concretes.

