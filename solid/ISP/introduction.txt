ğŸ”· I â€“ Interface Segregation Principle (ISP)
âœ… Definition:
Clients should not be forced to depend on interfaces they do not use.

ğŸ§  What It Means in Go
In Go, large interfaces are discouraged. Instead, you should define small, focused interfaces so that types only implement what they actually need.

ğŸš« Bad Example â€“ Violating ISP
type MultiFunctionDevice interface {
	Print()
	Scan()
	Fax()
}

type OldPrinter struct{}

func (op OldPrinter) Print() { fmt.Println("Printing...") }
func (op OldPrinter) Scan()  { panic("Scan not supported") }  // âŒ
func (op OldPrinter) Fax()   { panic("Fax not supported") }   // âŒ
Here, OldPrinter is forced to implement methods it doesn't support.

This violates ISP and increases coupling and potential bugs.

âœ… Good Example â€“ Following ISP
type Printer interface {
	Print()
}

type Scanner interface {
	Scan()
}

type Faxer interface {
	Fax()
}

type OldPrinter struct{}
func (op OldPrinter) Print() { fmt.Println("Printing...") } // âœ… Only what it needs
Now each device only implements what it truly supports.

If you want a device that can do all three, you can compose:

type MultiFunctionDevice interface {
	Printer
	Scanner
	Faxer
}
ğŸ§  Key Benefit of ISP
Problem Solved	Explanation
Reduces unused method implementations	Less boilerplate, cleaner code
Allows granular mocking/testing	Test only the needed behavior
Easier maintenance & evolution	Interfaces evolve independently without breaking others

